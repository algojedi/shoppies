{"version":3,"sources":["app/hooks.ts","features/nominations/nominationsSlice.ts","features/movie-results/movieResultsSlice.ts","features/movie/movie.ts","app/store.ts","components/nomination-card/NominationCard.tsx","features/nominations/Nominations.tsx","components/movie-card/MovieCard.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["useSelector","nominationsSlice","createSlice","name","initialState","nominations","reducers","addNomination","state","action","payload","length","findIndex","movie","imdbID","push","removeNomination","index","id","splice","actions","selectNoms","getUniqueList","arr","Map","map","item","values","emptyResponse","Search","totalResults","Response","pageNumber","fetchMovies","createAsyncThunk","userData","thunkApi","a","selection","userInput","formattedSelection","trim","replaceAll","url","pageNumUrl","page","fetch","response","status","console","log","rejectWithValue","message","json","data","uniqueList","movieResultsSlice","error","movies","extraReducers","builder","addCase","pending","fulfilled","Number","parseInt","rejected","selectMovies","selectStatus","selectPageNumber","selectTotalPages","Math","ceil","middleware","getDefaultMiddleware","logger","store","configureStore","reducer","nominationsReducer","moviesReducer","devTools","useTypedSelector","NominationCard","dispatch","useDispatch","Title","Year","Poster","className","onClick","Nominations","MovieCard","nominees","toast","configure","isNominated","find","m","alt","src","disabled","position","autoClose","hideProgressBar","closeOnClick","pauseOnHover","draggable","progress","undefined","App","useState","input","setInput","debouncedSearchTerm","value","delay","debouncedValue","setDebouncedValue","useEffect","handler","setTimeout","clearTimeout","useDebounce","observer","useRef","totalPages","currentPage","lastElementRef","useCallback","node","table","current","disconnect","IntersectionObserver","entries","check","isIntersecting","observe","type","placeholder","onChange","e","target","ref","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.a8675bf9.chunk.js","sourcesContent":["import { useEffect, useState } from 'react'\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\n// import type { RootState, AppDispatch } from './store'\nimport type { RootState } from './store'\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\n// export const useAppDispatch = () => useDispatch<AppDispatch>()\n// export const useAppDispatch = () => useDispatch<AppDispatch>()\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector\n\n// taken from useHooks.com\nexport function useDebounce<T>(value: T, delay: number): T {\n    // State and setters for debounced value\n    const [debouncedValue, setDebouncedValue] = useState<T>(value)\n    useEffect(\n        () => {\n            // Update debounced value after delay\n            const handler = setTimeout(() => {\n                setDebouncedValue(value)\n            }, delay)\n            // Cancel the timeout if value changes (also on delay change or unmount)\n            // This is how we prevent debounced value from updating if value is changed ...\n            // .. within the delay period. Timeout gets cleared and restarted.\n            return () => {\n                clearTimeout(handler)\n            }\n        },\n        [value, delay] // Only re-call effect if value or delay changes\n    )\n    return debouncedValue\n}\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { RootState, AppThunk } from '../../app/store'\nimport { Movie } from '../movie/movie'\n\nexport interface NominationsState {\n    nominations: Movie[]\n}\n\nconst initialState: NominationsState = {\n    nominations: []\n}\n\nconst addNominationReducer = (\n    state: NominationsState,\n    action: PayloadAction<Movie>\n) => {\n    const { payload } = action\n    if (state.nominations.length === 5) return\n    const index = state.nominations.findIndex(\n        (movie: Movie) => movie.imdbID === payload.imdbID\n    )\n    // do not add movie already nominated\n    if (index < 0) state.nominations.push(payload)\n}\n\nconst removeNominationReducer = (\n    state: NominationsState,\n    action: PayloadAction<{ id: string }>\n) => {\n    const { payload } = action\n    const index = state.nominations.findIndex(\n        (movie: Movie) => movie.imdbID === payload.id\n    )\n    if (index >= 0) state.nominations.splice(index, 1)\n}\n\nconst nominationsSlice = createSlice({\n    name: 'nominations',\n    initialState,\n    // The `reducers` field lets us define reducers and generate associated actions\n    reducers: {\n        addNomination: addNominationReducer,\n        removeNomination: removeNominationReducer\n    }\n})\n\n// export const { addNomination, removeNomination } = nominationsSlice.actions\nexport const {\n    // addNomination: addNominationAction,\n    // removeNomination: removeNominationAction\n    addNomination,\n    removeNomination\n} = nominationsSlice.actions\n\nexport const selectNoms = (state: RootState) => state.nominations.nominations\nexport default nominationsSlice.reducer\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { RootState, AppThunk } from '../../app/store'\nimport {\n    MovieResultsFetchResponse,\n    Movie,\n    resultsPerPage\n} from '../movie/movie'\nexport interface MovieResultsState {\n    status: 'loading' | 'idle'\n    error: string | null\n    movies: Movie[]\n    totalResults: number\n    pageNumber: number\n}\n\nconst initialState: MovieResultsState = {\n    status: 'idle',\n    error: null,\n    movies: [],\n    totalResults: 0,\n    pageNumber: 0\n}\n\n// This type describes the error object structure:\ntype FetchMoviesError = {\n    message: string\n}\nfunction getUniqueList(arr: Movie[]): Movie[] {\n    return [...new Map(arr.map((item) => [item.imdbID, item])).values()]\n}\nexport interface UserData {\n    page: number\n    selection: string\n}\n\nconst emptyResponse: MovieResultsFetchResponse = {\n    Search: [],\n    totalResults: '0',\n    Response: 'False',\n    pageNumber: 0\n}\n\nconst formatSelection = (userInput: string) => {\n    const result = userInput.trim()\n    // replace possible blank spaces in search title\n    return result.replaceAll(' ', '+')\n}\nexport const fetchMovies = createAsyncThunk<\n    MovieResultsFetchResponse,\n    UserData,\n    { rejectValue: FetchMoviesError }\n>('movies/fetch', async (userData, thunkApi) => {\n    // >\n    // 'movies/fetch',\n    // async (userData: UserData) => {\n    if (userData.selection == '') return emptyResponse\n    const formattedSelection = formatSelection(userData.selection)\n    let url = `http://www.omdbapi.com/?apikey=ca4f8507&type=movie&s=${formattedSelection}`\n    const pageNumUrl = `&page=${userData.page}`\n    const response = await fetch(url + pageNumUrl)\n    // console.log({ url: url + pageNumUrl })\n    if (response.status !== 200) {\n        // Return the error message for server error\n        console.log('error message when fetching')\n        return thunkApi.rejectWithValue({\n            message: 'Failed to fetch movies.'\n        }) // as FetchMoviesError\n    }\n    const data: MovieResultsFetchResponse = await response.json()\n    console.log({ data })\n    const { Response, totalResults, Search } = data\n    if (Response == 'False') return emptyResponse\n\n    // api returns duplicates in some search results\n    const uniqueList = getUniqueList(Search) // Search property contains the list of movies\n    // const count = Number.parseInt(totalResults)\n    return {\n        Search: uniqueList,\n        Response,\n        totalResults,\n        pageNumber: userData.page\n    } as MovieResultsFetchResponse\n})\n\nexport const movieResultsSlice = createSlice({\n    name: 'movieResults',\n    initialState,\n    reducers: {},\n    extraReducers: (builder) => {\n        builder.addCase(fetchMovies.pending, (state: MovieResultsState) => {\n            state.status = 'loading'\n            state.error = null\n        })\n\n        builder.addCase(fetchMovies.fulfilled, (state, { payload }) => {\n            // state.movies = [...payload]\n            // state.movies = payload.state.status = 'idle'\n            if (payload.pageNumber > 1) {\n                state.movies = getUniqueList([\n                    ...state.movies,\n                    ...payload.Search\n                ])\n            } else {\n                state.movies = [...payload.Search]\n            }\n            state.status = 'idle'\n            state.pageNumber = payload.pageNumber\n            state.totalResults = Number.parseInt(payload.totalResults)\n        })\n\n        builder.addCase(fetchMovies.rejected, (state, { payload }) => {\n            // if (payload) state.error = payload.message\n            // TODO: display error somehow\n            state.status = 'idle'\n        })\n    }\n})\n\n// Create and export the selector:\nexport const selectMovies = (state: RootState) => state.movies.movies\nexport const selectStatus = (state: RootState) => state.movies.status\nexport const selectPageNumber = (state: RootState) => state.movies.pageNumber\nexport const selectCount = (state: RootState) => state.movies.totalResults\nexport const selectTotalPages = (state: RootState) =>\n    Math.ceil(state.movies.totalResults / resultsPerPage)\n\nexport default movieResultsSlice.reducer\n","export interface Movie {\n    Title: string\n    Year: string\n    imdbID: string\n    Type: string\n    Poster: string\n}\nexport interface MovieResultsFetchResponse {\n    Search: Movie[]\n    totalResults: string\n    Response: string\n    pageNumber: number\n}\n\nexport const resultsPerPage = 10\n","import {\n    configureStore,\n    ThunkAction,\n    Action,\n    getDefaultMiddleware\n} from '@reduxjs/toolkit'\nimport { TypedUseSelectorHook, useSelector } from 'react-redux'\nimport { logger } from 'redux-logger'\nimport nominationsReducer from '../features/nominations/nominationsSlice'\nimport moviesReducer from '../features/movie-results/movieResultsSlice'\n\nconst inProduction = process.env.NODE_ENV === 'production'\nconst middleware = [...getDefaultMiddleware(), logger]\nexport const store = configureStore({\n    reducer: {\n        nominations: nominationsReducer,\n        movies: moviesReducer\n    },\n    middleware,\n    devTools: !inProduction\n})\n\n// export type AppDispatch = typeof store.dispatch\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppThunk<ReturnType = void> = ThunkAction<\n    ReturnType,\n    RootState,\n    unknown,\n    Action<string>\n>\nexport const useTypedSelector: TypedUseSelectorHook<RootState> = useSelector\n","import { Movie } from '../../features/movie/movie'\nimport { addNomination, removeNomination } from '../../features/nominations/nominationsSlice'\nimport { useDispatch } from 'react-redux';\n// import { FaRegWindowClose } from \"react-icons/fa\";\nimport { MdClose } from \"react-icons/md\";\nimport './nominationCard.scss'\n\n// const MovieCard = ({ Title, Year, Poster, imdbID }: Movie) => {\nconst NominationCard = (movie: Movie) => {\n    const dispatch = useDispatch()\n    const { Title, Year, Poster, imdbID } = movie\n    return (\n        <section className='nomination-card'>\n            <section className=\"nomination-card_info\">\n                <span className='nomination-card_info_title'>\n                    {Title}\n                </span>\n                <span className='nomination-card_info_year'>\n                    {Year}\n                </span>\n            </section>\n            {/* <img src={Poster} /> */}\n            <div className='nomination-card_remove-btn' onClick={() => dispatch(removeNomination({ id: movie.imdbID }))}>\n                <MdClose className='nomination-card_remove-btn_icon' />\n            </div>\n        </section>\n    )\n}\n\nexport default NominationCard","\nimport React, { useState } from 'react';\n\n// import { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport {\n    addNomination,\n    removeNomination,\n    selectNoms\n} from './nominationsSlice';\nimport styles from './Nominations.module.css';\nimport { Movie } from '../movie/movie';\nimport { useTypedSelector } from '../../app/store';\nimport { useDispatch } from 'react-redux';\nimport NominationCard from '../../components/nomination-card/NominationCard';\nimport './nominations.scss'\n\nexport function Nominations() {\n    // const dispatch = useAppDispatch();\n    const dispatch = useDispatch()\n    const movies = useTypedSelector(selectNoms)\n\n    return (\n        <section className='nominations'>\n\n            <h3 className='nominations_title'>\n                Nominations\n            </h3>\n            <ul className='nominations_movie-list'>\n                {movies.map((movie: Movie) => <li key={movie.imdbID}\n                    className='movie'><NominationCard {...movie} /></li>)}\n            </ul>\n\n        </section>\n    );\n}\n","import React from 'react'\nimport { Movie } from '../../features/movie/movie'\nimport { addNomination, selectNoms } from '../../features/nominations/nominationsSlice'\nimport { useDispatch } from 'react-redux';\nimport { useTypedSelector } from '../../app/store';\nimport 'react-toastify/dist/ReactToastify.css';\nimport './movie-card.scss'\nimport { toast } from 'react-toastify'\n\nconst MovieCard = (movie: Movie) => {\n    const dispatch = useDispatch()\n    const nominees = useTypedSelector(selectNoms)\n\n    toast.configure()\n    const { Title, Year, Poster, imdbID } = movie\n    let isNominated = false\n    const index = nominees.find(m => m.imdbID === imdbID)\n    if (index) {\n        isNominated = true\n    }\n\n    const nominate = () => {\n        if (nominees.length === 5) {\n            toast.error('Limit of five nominations', {\n                className: \"error-toast\",\n                position: \"top-center\",\n                autoClose: 5000,\n                hideProgressBar: true,\n                closeOnClick: true,\n                pauseOnHover: false,\n                draggable: false,\n                progress: undefined,\n            })\n            return\n        }\n        dispatch(addNomination(movie))\n    }\n    return (\n        <section className='movie-card'>\n            <img alt='NO PHOTO AVAILABLE' className='movie-card_img' src={Poster} />\n            <section className=\"movie-card_details\">\n                <section className=\"movie-card_details_info\">\n                    <h3 className='movie-card_details_info_title'>\n                        {Title}\n                    </h3>\n                    <h4 className='movie-card_details_info_year'>\n                        {Year}\n                    </h4>\n                </section>\n                <button disabled={isNominated}\n                    className='movie-card_details_nominate-btn'\n                    onClick={nominate}>Nominate </button>\n            </section>\n        </section>\n    )\n}\n\nexport default MovieCard","import React, { useCallback, useEffect, useRef, useState } from 'react'\nimport { useDispatch } from 'react-redux'\nimport { useDebounce } from './app/hooks'\nimport { useTypedSelector } from './app/store'\nimport { fetchMovies, selectMovies, selectPageNumber, selectStatus, selectTotalPages } from './features/movie-results/movieResultsSlice'\nimport { Movie } from './features/movie/movie'\nimport { Nominations } from './features/nominations/Nominations'\nimport MovieCard from './components/movie-card/MovieCard'\nimport './App.scss'\n\nfunction App() {\n    const dispatch = useDispatch()\n    const [input, setInput] = useState('')\n    const debouncedSearchTerm: string = useDebounce<string>(input, 500);\n    const status = useTypedSelector(selectStatus)\n    const movies: Movie[] = useTypedSelector(selectMovies)\n    const observer = useRef<HTMLDivElement | IntersectionObserver | null>(null)\n    const totalPages = useTypedSelector(selectTotalPages)\n    const currentPage = useTypedSelector(selectPageNumber)\n    const lastElementRef = useCallback((node) => {\n        if (status === 'loading') return\n        console.table({ totalPages, currentPage })\n        // if (observer.current) observer.current.disconnect()\n        if (observer.current) {\n            (observer.current as IntersectionObserver).disconnect()\n        }\n        observer.current = new IntersectionObserver(entries => {\n            const check = currentPage != totalPages\n            if (entries[0].isIntersecting && check) {\n                console.log('should fetch more movies')\n                dispatch(fetchMovies({ selection: input, page: currentPage + 1 }))\n            }\n            if (entries[0].isIntersecting) {\n                console.log('intersection!')\n            }\n            else console.log('no intersection')\n        })\n        if (node) {\n            observer.current.observe(node)\n        }\n    }, [currentPage, status])\n\n\n\n    // Effect for API call\n    useEffect(\n        () => {\n            if (debouncedSearchTerm) {\n                dispatch(fetchMovies({ selection: input, page: 1 }))\n            } else {\n                dispatch(fetchMovies({ selection: '', page: 1 })) // reset list\n            }\n        },\n        [debouncedSearchTerm] // Only call effect if debounced search term changes\n    );\n\n    return (\n        <>\n            <section className='navbar'>\n                <h1 className='navbar_title'>The Shoppies</h1>\n                <input className='navbar_input' type='text' value={input} placeholder='Search movie...'\n                    onChange={(e: React.ChangeEvent<HTMLInputElement>) => setInput(e.target.value)} />\n                {/* <section className='navbar_status-indicator'>{status}</section> */}\n            </section>\n            <Nominations />\n            <section className='search-results'>\n                <ul className='search-results_movie-list list'>\n                    {movies.map((movie: Movie, index) => {\n                        if (movies.length === index + 1) {\n                            return (<li ref={lastElementRef} key={movie.imdbID} className='movie'>\n                                <MovieCard {...movie} />\n                            </li>)\n                        }\n                        return (<li key={movie.imdbID} className='movie'>\n                            <MovieCard {...movie} />\n                        </li>)\n                    })}\n\n                </ul>\n            </section>\n        </>\n    )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}